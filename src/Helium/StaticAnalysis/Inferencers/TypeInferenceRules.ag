-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
--
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Contains all the typing rules for an UHA abstract syntax tree.
--
-----------------------------------------------------------------------------

----------------------------------------------------------------------------------------
-- Type Inferencing : Module

SEM Module
  | Module
      loc  -- Solve the type constraints.
           . (SolveResult betaUniqueAtTheEnd substitution typeschemeMap predicates solveErrors) = @solveResult
           . (solveResult, logEntries) =
                (selectConstraintSolver @lhs.options (setClassEnvironment @classEnv @lhs.importEnvironment))
                   @classEnv
                   @orderedTypeSynonyms
                   @body.betaUnique
                   @body.constraints

           . orderedTypeSynonyms = getOrderedTypeSynonyms @lhs.importEnvironment
           . classEnv            = -- extend the set of imported instance declarations with the
                                   -- derived instances
                                   foldr (\(n, i) -> insertInstance (show n) i)
                                         (classEnvironment @lhs.importEnvironment)
                                         @body.collectInstances
           . tyConEnv            = typeConstructors @lhs.importEnvironment
           . typeErrors          = map (convertTypeError (fromQualName (convertMap @tyConEnv))) @typeErrorsBase
           . typeErrorsBase      =  let unqualifier = unQualifyName @lhs.importEnvironment
                                    in case makeTypeErrors @lhs.options @classEnv unqualifier @orderedTypeSynonyms @substitution @solveErrors of
                                        []   -> if NoOverloadingTypeCheck `elem` @lhs.options
                                                   then filter (\(TypeError _ ms _ _) -> not $ isInfixOf "Illegal overloaded type" $ show ms) @body.collectErrors
                                                   else @body.collectErrors
                                        errs -> reverse errs
           . warnings            = @body.collectWarnings -- ++ @tooSpecificWarnings
           . assumptions         = let f xs = [ (n, @substitution |-> tp) | (n, tp) <- xs ]
                                   in M.map f @body.assumptions
           . initialScope        = M.keys (typeEnvironment @lhs.importEnvironment)
           . monos               = map TVar @monomorphics
           . monomorphics        = ftv (  (map (\(_, scheme, _) -> scheme) $ M.elems $ valueConstructors @lhs.importEnvironment) 
                                       ++ (M.elems $ typeEnvironment   @lhs.importEnvironment)
                                       )
           . typeConstructors    = typeConstructors @lhs.importEnvironment
           . classMemberTypeSchemes = Nothing
                                  
      body . typeschemeMap = M.fromList (M.assocs @typeschemeMap) -- was a copy rule.
           . betaUnique          = if null @monomorphics
                                     then 0
                                     else maximum @monomorphics + 1
            . instanceTypes     = []
            . variableMapping   = Nothing
            . requiredPredicates = @predicates
            . moduleName = @name.name

SEM MaybeName [ | | isNothing : Bool name : { Maybe Name } ]
    | Nothing             lhs.isNothing = True
                          lhs.name      = Nothing
    | Just                lhs.isNothing = False
                          lhs.name      = Just @name.self

---------------------------------------------------------------------------------------
-- Type Inferencing : Body

ATTR Body
    [ typeConstructors      : TypeConstructorEnvironment
      monos                 : Monos
    | betaUnique            : Int
    | assumptions           : Assumptions
      constraints           : ConstraintSet
    ]

SEM Body
  | Hole
      lhs . assumptions = noAssumptions
          . constraints = emptyTree
  | Body
      declarations . bindingGroups    = []
      lhs . assumptions               = @loc.assumps
      (loc.csetBinds,loc.assumps)     = (typeEnvironment @lhs.importEnvironment .:::. (@aset)) @cinfo
      loc . constraints               = (@csetBinds).>>. @cset

      (loc.aset, loc.cset, loc.inheritedBDG, loc.chunkNr, lhs.betaUnique, loc.implicitsFM) =
         let inputBDG = (True, @lhs.currentChunk, @declarations.uniqueChunk, @lhs.monos, @declarations.typeSignatures, Nothing, @declarations.betaUnique)
         in performBindingGroup inputBDG @declarations.bindingGroups


---------------------------------------------------------------------------------------
-- Type Inferencing : Declaration, Declarations, MaybeDeclarations
ATTR Declaration Declarations MaybeDeclarations RightHandSide Qualifier Qualifiers 
    Body Expression Expressions FunctionBinding FunctionBindings Alternative Alternatives 
    MaybeExpression GuardedExpression GuardedExpressions RecordExpressionBinding 
    RecordExpressionBindings Statement Statements
    [
        classMemberTypeSchemes : {Maybe [(Name, TpScheme)]}
        instanceTypes : {[(Name, TpScheme)]}
        moduleName : {Maybe Name}
    | 
    |
]
ATTR Declaration Declarations MaybeDeclarations 
            [   typeConstructors:TypeConstructorEnvironment
                monos:Monos 
            |   betaUnique:Int 
            |   boundBetas      USE {(++)} {[]} : {[(Name, Tp, [Tp])]} 
                typeMemberBindings  USE {(++)} {[]} : {[(Name, TpScheme)]}
            ]
ATTR Declaration Declarations                   [ inheritedBDG:InheritedBDG | bindingGroups:BindingGroups | ]
ATTR                          MaybeDeclarations [ | assumptions:Assumptions constraints:ConstraintSet | ]

SEM Declaration

  | FunctionBindings
      lhs      . bindingGroups = @mybdggrp : @lhs.bindingGroups
      lhs      . boundBetas    = [(@bindings.name, @beta, @betasLeft ++ [@betaRight])]
      bindings . betaUnique    = @lhs.betaUnique + 1 + @bindings.numberOfPatterns
               . monos         = findMono @bindings.name @lhs.inheritedBDG ++ @lhs.monos
      loc      . beta          = TVar @lhs.betaDeclUnique
               . betaRight     = TVar @lhs.betaUnique
               . betasLeft     = take @bindings.numberOfPatterns (map TVar [@lhs.betaUnique + 1..])
               . newcon        = (@beta .==. foldr (.->.) @betaRight @betasLeft) @cinfo
               . functionType  = lookup @bindings.name @lhs.instanceTypes
               . mybdggrp      = let 
                                    assumptions = filterAssumptions @bindings.assumptions
                                    filterAssumptions = M.filterWithKey (\k _ -> not $ k `elem` map fst @lhs.instanceTypes )

                                  in ( if @lhs.isTopLevel then
                                    M.fromList [(@bindings.name, @beta), (addQualified @lhs.moduleQual @bindings.name, @beta)] 
                                    else M.fromList [(@bindings.name, @beta)] 
                                 , assumptions
                                 , [ Node [ Phase (-1) [@newcon]
                                          , Receive @lhs.betaDeclUnique
                                          , Node @bindings.constraintslist
                                          , if isJust @lhs.instanceName then 
                                                let 
                                                    functionType = lookup @bindings.name @lhs.instanceTypes
                                                in maybe emptyTree (\ft -> listTree [
                                                        (@beta !::!  replaceName (head $ fromJust @lhs.variableMapping) ft) [] @cinfo
                                                    ]) functionType
                                            else
                                                emptyTree
                                        ]
                                   ]
                                 )

  | PatternBinding
      lhs           . bindingGroups = @mybdggrp : @lhs.bindingGroups
      pattern       . betaUnique    = @lhs.betaUnique + 1
      righthandside . monos         = findMono (chead (M.keys (@pattern.environment))) @lhs.inheritedBDG ++ @lhs.monos
      loc           . betaRight     = TVar @lhs.betaDeclUnique
                    . newcon        = [ (@betaRight .==. @pattern.beta) @cinfo ]
                    . mybdggrp      = ( if @lhs.isTopLevel then
                                            M.foldrWithKey (\n result old -> M.insert (addQualified @lhs.moduleQual n) result old) @pattern.environment @pattern.environment
                                            else @pattern.environment
                                      , @righthandside.assumptions
                                      , [ @newcon .>.
                                          Node [ @pattern.constraints
                                               , @righthandside.constraints
                                               ]
                                          , listTree @mainConstraint
                                        ]
                                      )
                    . betaMain       = TVar $ @lhs.betaUnique
                    . mainConstraint =  if "main" `elem` map (getNameName . fst) (M.toList @pattern.environment) && (getNameName <$> @lhs.moduleName) == Just "Main" then
                                            [(@pattern.beta .==. TApp (TCon "IO") @betaMain) @cinfo]
                                        else
                                            []
                                    
  | TypeSignature
        lhs         . betaUnique = @lhs.betaUnique + 1
        lhs         . typeMemberBindings = map (\name -> (name, makeTpSchemeFromType $ convertTypeToQualified @lhs.importEnvironment @type.self)) @names.self
  | Class
        lhs         . bindingGroups = (@loc.environment, @where.assumptions, @loc.classMembers) : @lhs.bindingGroups
        where       . assumptions   = noAssumptions
        where       . constraints   = emptyTree
        where       . betaUnique    = @lhs.betaUnique + 1 + (length @where.typeMemberBindings)
        where       . classMemberTypeSchemes = appendClasses @where.typeMemberBindings @lhs.allTypeSchemes
        where       . classPredicate = Just (@qualName, @simpletype.typevariables)
        loc         . environment   = M.fromList $ map (\((n, _), tp)->(n, tp)) @members
        loc         . classBeta     = TVar @lhs.betaUnique
        loc         . classMembers  = (map (\((_, tpscheme), tp) -> 
                                            let 
                                                typeVars = @simpletype.typevariables
                                                className = @qualName
                                                typeIndices = filter (\(_, s) -> s `elem` (map getNameName typeVars)) (getQuantorMap tpscheme)
                                                typeVariablesMapped = map (\(n, s) -> (fromJust $ find (\tv -> getNameName tv == s) typeVars, TVar n)) typeIndices
                                                tpWContext = addContextToType className typeVariablesMapped tpscheme
                                            in unitTree $ (tp .::. tpWContext) emptyConstraintInfo
                                        ) @members)
                                        ++
                                        [@where.constraints]
        loc         . members       = zip @where.typeMemberBindings (map TVar [(@lhs.betaUnique + 1)..])
  | Instance
        loc      . qualifiedSuperClasses = map (\(nm, tp) -> (show $ convertClassNameToQualified @lhs.importEnvironment $ nameFromString nm, tp)) @superClasses
        lhs      . collectErrors        = let 
                                            unqualifier = unQualifyName @lhs.importEnvironment
                                            checkPredicate :: Predicate -> [TypeError]
                                            checkPredicate (Predicate pn v) 
                                                | p `elem` map (superClassToPredicate @instanceBetas) @qualifiedSuperClasses = []
                                                | v `elem` map snd @instanceBetas = [makeMissingInstancePredicateError @range.self (unqualifier @qualName)
                                                                                    (show $ makeTpSchemeFromType (chead $ @types.self)) (convertPredicate unqualifier p) 
                                                                                    (map (\(n,v') -> (convertString unqualifier n, v')) @superClasses) @instanceBetas]
                                                | otherwise = []
                                                where
                                                    p = Predicate (show $ convertClassNameToQualified @lhs.importEnvironment $ nameFromString pn) v
                                          in (concatMap checkPredicate @lhs.requiredPredicates) ++ @lhs.collectErrors
        where   . assumptions           = noAssumptions
        where   . constraints           = emptyTree
        where   . variableMapping       = Just [(chead $ fst $ @classMembers, @instBeta)]
        where   . classMemberTypeSchemes = appendClasses ((maybe (error "Invalid class name") ((map (\(n, tps, _, _)->(n, tps))).snd)
                                            $ M.lookup @qualName (classMemberEnvironment @lhs.importEnvironment))) @lhs.allTypeSchemes
        where   . instanceTypes         = maybe [] ((map (\(n, tps, _, _)->(n, let
                                                    typeVars = fst @classMembers
                                                    className = @qualName
                                                    typeIndices = filter (\(_, s) -> s `elem` (map getNameName typeVars)) (getQuantorMap tps)
                                                    typeVariablesMapped = map (\(n', s) -> (fromJust $ find (\tv -> getNameName tv == s) typeVars, TVar n')) typeIndices
                                                    tpWContext = addContextToType className typeVariablesMapped tps
                                                in tpWContext))).snd) $ M.lookup @qualName (classMemberEnvironment @lhs.importEnvironment)
        loc     . classMembers          = selectClass @lhs.importEnvironment @qualName
        lhs     . bindingGroups         = (noAssumptions,  @where.assumptions, @loc.constraints) : @lhs.bindingGroups
        loc     . constraints           = [Node $ [@where.constraints] ++ @instanceConstraints]
        loc     . superPredicates       = map (
                                                (\s -> 
                                                    let 
                                                        Predicate _ tvar = prd
                                                        prd = superClassToPredicate @instanceBetas s
                                                        tv = (getNameName . fst . fromJust $ find (\ib -> tvar == snd ib) @instanceBetas)
                                                    in superClassToPredicateWithSource 
                                                        prd
                                                        (getNameName @qualName)
                                                        tv
                                                )
                                            ) @qualifiedSuperClasses
        loc     . qualifiedInstanceTpScheme = convertTpSchemeToQualified @lhs.importEnvironment @instanceTpScheme
        loc     . instanceConstraints   = [     
                                                (   [TC2 $ Assume prd @cinfo | prd <- map (superClassToPredicate @instanceBetas) @superClasses] ++
                                                    [(!::!) 
                                                        @loc.instBeta 
                                                        @qualifiedInstanceTpScheme
                                                        [] 
                                                        @cinfo ,
                                                    ((@loc.instBeta .==. convertTpToQualified @lhs.importEnvironment @loc.instsType) @loc.cinfo)
                                                ]) .>. Node []
                                            ]
        loc     . typeVariabeles        = namesInType (chead $ @types.self)
        loc     . memberSuperClassBeta  = [TVar v | v <- [(@lhs.betaUnique + 2 + length @typeVariabeles)..]]
        loc     . memberBetas           = matchClassDefinitionToInstanceDefinition 
                                                (maybe (error "Unknown class") (map (\(n, tp, _, _) -> (n, tp)).snd) $ M.lookup @qualName $ classMemberEnvironment @lhs.importEnvironment) $ 
                                                map (\(n, b, _) -> (n, b)) @where.boundBetas
        loc     . cinfo                 = resultConstraint "instance definition" @parentTree [SkolemizedTypeScheme ([], @qualifiedInstanceTpScheme), TypeSignatureLocation @range.self]
 
ATTR Constructors Constructor FieldDeclarations FieldDeclaration [ monos : Monos | bindingGroups : BindingGroups | ]
ATTR                          FieldDeclarations FieldDeclaration [ conName : Name | | ]

SEM Constructor 
  | Record fieldDeclarations . conName = @constructor.self

SEM FieldDeclaration
  | FieldDeclaration
      lhs . bindingGroups = @mybdggrp : @lhs.bindingGroups
      loc . recordEnv     = recordEnvironment @lhs.importEnvironment
          . fieldEnv      = fromMaybe (internalError 
                                "TypeInferenceRules.ag" 
                                "FieldDeclaration" 
                                "Specified record could not be found") 
                                    (M.lookup @lhs.conName @recordEnv)
          . selTypes      = catMaybes $ map (\n -> do
                                (_, _, _, ts) <- M.lookup n @fieldEnv
                                return (n, ts)) @names.self
          . zippedSelCon  = zip @selTypes [@lhs.betaDeclUnique..]
          . newcon        = map (\((n, ts), beta) -> (TVar beta .::. ts) @loc.cinfo) @zippedSelCon
          . mybdggrp      = ( foldr (\((n, _), beta) p -> M.insert n (TVar beta) p) M.empty @zippedSelCon
                            , M.empty
                            , [ Node $ [ Phase (-1) @newcon
                                     , Receive @lhs.betaDeclUnique
                                     , emptyTree
                                     ] ++ map (Receive . snd) @zippedSelCon
                              ]
                            )

{
appendClasses :: [(Name, TpScheme)] -> M.Map NameWithRange TpScheme -> Maybe [(Name, TpScheme)]
appendClasses typeMemberBindings allTypeSchemes = Just (map lookupScheme typeMemberBindings)
    where
        lookupScheme :: (Name, TpScheme) -> (Name, TpScheme)
        lookupScheme (n, _) = (n, fromMaybe ((fromJust $ lookup n $ map (\(NameWithRange n', t) -> (n', t)) $ M.toList allTypeSchemes)) $ M.lookup (NameWithRange n) (allTypeSchemes))

constructDictionaryName :: Name -> String -> Name
constructDictionaryName (Name_Identifier range modules origin name) s = 
      Name_Identifier range modules origin ("($dict" ++ name ++ "$" ++ s ++ ")")    
constructDictionaryName _ _ = error "<unforseen situation in constructDictionaryName>"

classVariablesToBeta :: Int -> Names -> [(Name, Tp)]
classVariablesToBeta _ [] = []
classVariablesToBeta c (n:ns) = (n, TVar c) : classVariablesToBeta (c + 1) ns

substituteClassVariables    :: TpScheme -- ^ The type which has to substituted
                            -> Name     -- ^ The type variable of the class
                            -> Tp       -- ^ The beta which has to be placed in place
                            -> TpScheme
substituteClassVariables tps classVariable beta = ntps
    where
        unqual = unquantify tps 
        ntps = quantify (map fst nqmap) ntp
        ntp = substitution |-> unqual
        nqmap = filter (\x -> snd x /= cvString ) qmap
        qmap = getQuantorMap tps
        cvString = getNameName classVariable
        substitution = listToSubstitution [(numb, beta) | (numb, tvar) <- qmap, tvar == cvString]


matchClassDefinitionToInstanceDefinition :: [(Name, TpScheme)] -> [(Name, Tp)] -> [(Name, TpScheme, Tp)]
matchClassDefinitionToInstanceDefinition classMember insMember = catMaybes $ map combineMember insMember
    where
        combineMember :: (Name, Tp) -> Maybe (Name, TpScheme, Tp)
        combineMember (name, tp) = 
                case lookup name classMember of
                    Nothing -> Nothing
                    Just tps -> Just (name, tps, tp)

getClassTypeVariables :: (Names, a) -> Names
getClassTypeVariables = fst

getClassFunctions :: (Names, [(Name, TpScheme, Bool, HasDefault)]) -> [(Name, TpScheme, Bool, HasDefault)]
getClassFunctions = snd

selectClass :: ImportEnvironment -> Name -> (Names, [(Name, TpScheme, Bool, HasDefault)])
selectClass env name =  let err = internalError "TypeInferenceRules.ag" "selectClass" "Specified class could not be found"
                        in M.findWithDefault err name (classMemberEnvironment env)

getInstanceMembers :: ImportEnvironment -> (Name, Tp) -> (Names, [(String, String)])
getInstanceMembers env (name, instType) =   let err = internalError "TypeInferenceRules.ag" "getInstanceMembers" "Specified instance could not be found"
                                in fromMaybe err $ findInMap (\(iname, tv) _ -> name == iname && (instanceEq tv instType)) (instanceEnvironment env)

findInMap :: (k -> a -> Bool) -> M.Map k a -> Maybe a
findInMap f m = let filtered = M.filterWithKey f m
                in if length filtered == 1 then
                        Just $ snd $ chead (M.toList filtered)
                    else
                        Nothing

instanceEq :: Tp -> Tp -> Bool
instanceEq (TCon c1) (TCon c2) = c1 == c2
instanceEq (TVar _) (TVar _) = True
instanceEq (TVar _) (TCon "???") = True
instanceEq (TCon "???") (TVar _) = True
instanceEq (TApp f1 a1) (TApp f2 a2) = instanceEq f1 f2 && instanceEq a1 a2
instanceEq _            _            = False


getInstanceFunctions :: (Instance, Types, [(Name, TpScheme)]) -> [(Name, TpScheme)]
getInstanceFunctions (_, _, funcs) = funcs

convertTypeError :: (Name -> Name) -> TypeError -> TypeError
convertTypeError f (TypeError ran theLines table hints) = 
   let newtab = map (\(b, block1, block2) -> (b, changeMessageBlock f block1, changeMessageBlock f block2)) table
       newlines = map (changeMessageLine f) theLines
       newhints = map (\(str, block) -> (str, changeMessageBlock f block)) hints
   in TypeError ran newlines newtab newhints

changeMessageLine :: (Name -> Name) -> MessageLine -> MessageLine
changeMessageLine f (MessageOneLiner block) = MessageOneLiner (changeMessageBlock f block)
changeMessageLine f (MessageTable table) = MessageTable $ map (\(indent, block1, block2) -> (indent, changeMessageBlock f block1, changeMessageBlock f block2)) table
changeMessageLine f (MessageHints str blocks) = MessageHints str (map (changeMessageBlock f) blocks)

changeMessageBlock :: (Name -> Name) -> MessageBlock -> MessageBlock
changeMessageBlock f (MessageType tps) = MessageType (convertTpScheme f tps)
changeMessageBlock f (MessagePredicate (Predicate str tp)) = MessagePredicate (Predicate str (convertTp f tp))
changeMessageBlock f (MessageCompose blocks) = MessageCompose (map (changeMessageBlock f) blocks)
changeMessageBlock _ block = block
}

SEM MaybeDeclarations
  | Just
      declarations . bindingGroups  = []
      (lhs.assumptions, lhs.constraints, loc.inheritedBDG, loc.chunkNr, lhs.betaUnique, loc.implicitsFM) = 
         let inputBDG   = (False, @lhs.currentChunk, @declarations.uniqueChunk, @lhs.monos, @declarations.typeSignatures, mybdggroup, @declarations.betaUnique)
             mybdggroup = Just (@lhs.assumptions, [@lhs.constraints])
         in performBindingGroup inputBDG @declarations.bindingGroups

---------------------------------------------------------------------------------------
-- Type Inferencing : FunctionBinding, FunctionBindings

ATTR FunctionBinding FunctionBindings [ typeConstructors : TypeConstructorEnvironment betasLeft:Tps betaRight:Tp monos:Monos | betaUnique:Int 
                                      | assumptions:Assumptions numberOfPatterns:Int name:Name ]
ATTR FunctionBinding                  [ | | constraints:ConstraintSet]
ATTR                 FunctionBindings [ | | constraintslist:ConstraintSets]

SEM FunctionBinding

  | Hole
      loc . assumptions      = noAssumptions
          . constraints      = emptyTree
          . numberOfPatterns = 0
          . name             = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"
  | FunctionBinding
      righthandside . monos       = M.elems @lefthandside.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc           . constraints = @csetBinds .>>.
                                    Node [ @conLeft  .<. @lefthandside.constraints
                                         , @righthandside.constraints
                                         ]
                    . conLeft     = zipWith3 (\t1 t2 nr -> (t1 .==. t2) (@cinfoLeft nr)) @lefthandside.betas @lhs.betasLeft [0..]
      (loc.csetBinds,lhs.assumptions) = (@lefthandside.environment .===. @righthandside.assumptions) @cinfoBind

SEM FunctionBindings

  | Cons
      lhs . assumptions      = @hd.assumptions `combine` @tl.assumptions
          . numberOfPatterns = @hd.numberOfPatterns
          . name             = @hd.name
          . constraintslist  = @hd.constraints : @tl.constraintslist
  | Nil
      lhs . assumptions      = noAssumptions
          . numberOfPatterns = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
          . name             = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"
          . constraintslist  = []

---------------------------------------------------------------------------------------
-- Type Inferencing : LeftHandSide, RightHandSide

ATTR LeftHandSide RightHandSide [ typeConstructors : TypeConstructorEnvironment monos:Monos | betaUnique:Int | constraints:ConstraintSet ]
ATTR LeftHandSide               [ | | betas:Tps environment:PatternAssumptions numberOfPatterns:Int name:Name ]
ATTR              RightHandSide [ betaRight:Tp | | assumptions:Assumptions ]

SEM LeftHandSide
  | Function
      lhs . name             = @name.self
      loc . constraints      = Node @patterns.constraintslist


  | Infix
      lhs . numberOfPatterns = 2
          . environment      = @leftPattern.environment `M.union` @rightPattern.environment
          . betas            = [@leftPattern.beta,@rightPattern.beta]
          . name             = @operator.self
      loc . constraints      = Node [ @leftPattern.constraints
                                    , @rightPattern.constraints
                                    ]


  | Parenthesized
      lhs . numberOfPatterns = @lefthandside.numberOfPatterns + @patterns.numberOfPatterns
          . environment      = @lefthandside.environment `M.union` @patterns.environment
          . betas            = @lefthandside.betas ++ @patterns.betas
      loc . constraints      = Node ( @lefthandside.constraints : @patterns.constraintslist )

SEM RightHandSide

  | Expression
     lhs   . assumptions = @where.assumptions
           . constraints = @where.constraints
     where . assumptions = @expression.assumptions
           . constraints = @newcon .>. @expression.constraints
           . instanceName = Nothing
           . variableMapping = Nothing
     loc   . newcon      = [ (@expression.beta .==. @lhs.betaRight) @cinfo ]


  | Guarded
     lhs                . assumptions    = @where.assumptions
                        . constraints    = @where.constraints
     guardedexpressions . numberOfGuards = length @guardedexpressions.constraintslist
     where              . assumptions    = @guardedexpressions.assumptions
                        . instanceName   = Nothing
                        . constraints    = Node @guardedexpressions.constraintslist

---------------------------------------------------------------------------------------
-- Type Inferencing : Expression, Expressions, MaybeExpression

ATTR Expression Expressions MaybeExpression [ typeConstructors : TypeConstructorEnvironment monos:Monos | betaUnique:Int | assumptions:Assumptions ]
ATTR Expression                             [ | | beta:Tp constraints:ConstraintSet ]
ATTR            Expressions                 [ | | betas:Tps constraintslist:ConstraintSets ]
ATTR                        MaybeExpression [ | | beta:Tp constraints:ConstraintSet section:Bool ]
imports{
import Helium.Top.Top.Constraint.Qualifier
}

SEM Expression

  | Literal
      lhs . betaUnique  = @lhs.betaUnique + 1
      loc . assumptions = noAssumptions
          . constraints = unitTree ((@literal.literalType .==. @beta) @cinfo)
          . beta        = TVar @lhs.betaUnique

  | Constructor
      loc . assumptions  = noAssumptions
          . constraints  = listTree @newcon
          . beta         = TVar @lhs.betaDeclUnique
          . newcon       = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                              Nothing          -> []
                              Just (_, ctp, _) -> [ (@beta .::. ctp) @cinfo ]

  | RecordConstruction
      recordExpressionBindings . betaConstr = @beta
      lhs.betaUnique = @lhs.betaUnique + length @sortedFields
      loc . assumptions = @recordExpressionBindings.assumptions
          . constraints = @conRecord .>. @conFunc .>.
                            Node @recordExpressionBindings.constraintslist
          . (conRecord, conFunc, sortedFields)    
                = fromMaybe (internalError "TypeInferenceRules.ag" "RecordConstruction" "") $ do
                     let recordEnv = recordEnvironment @lhs.importEnvironment
                     recordFields <- M.lookup @name.self recordEnv
                     let sortedFields = sortOn (\(n, (i, _, _, _)) -> i) (M.assocs recordFields)
                     -- If some fields are omitted, use a default beta variable whose value will largely be ignored.
                     let sortedBetas = map (\(n, (i, _, _, _)) -> fromMaybe (TVar (@lhs.betaUnique + i + 1))
                            (lookup n @recordExpressionBindings.betasMap)) sortedFields
                     let recordFunc = foldr (.->.) @beta sortedBetas
                     (_, ctp, _) <- M.lookup @name.self (valueConstructors @lhs.importEnvironment)
                     let t = generalizeAll ([] .=>. snd (functionSpine (unqualify (unquantify ctp))))
                     return ( [(@beta .::. t) @cinfoResult]
                            , [(@betaFunc .==. recordFunc) @cinfoFunc, (recordFunc .::. ctp) @cinfoFunc]
                            , sortedFields
                            )

  | RecordUpdate
      recordExpressionBindings . betaConstr = @beta
      recordExpressionBindings . betaUnique = @expression.betaUnique
      expression . betaUnique = @lhs.betaUnique + length @sortedFields + 1
      loc . assumptions  = @expression.assumptions `combine` @recordExpressionBindings.assumptions
          . constraints  = @newcon .>. @conMissing .>. @conFunc .>. Node
                                [ @conExpr .<. @expression.constraints
                                , Node @recordExpressionBindings.constraintslist
                                ]
          . (newcon, conExpr, conFunc, conMissing, sortedFields)
                = fromMaybe (internalError "TypeInferenceRules.ag" "RecordUpdate" "") $ do
                    let recordEnv = recordEnvironment @lhs.importEnvironment

                    -- Given the fields used in the update try and find a constructor
                    let fieldsPresent = map fst @recordExpressionBindings.betasMap
                    let constructors = concat $ catMaybes $ map (\n -> M.lookup n (fieldLookup @lhs.importEnvironment)) fieldsPresent

                    -- Preference is given to constructors which contain the most fields
                    let constructor = head $ reverse $ sortOn (\n -> M.size $ fromJust (M.lookup n recordEnv)) constructors

                    -- Fetch the typescheme of the found constructor
                    (_, ctp, _) <- M.lookup constructor (valueConstructors @lhs.importEnvironment)

                    -- Fetch the fields of the constructor
                    recordFields <- M.lookup constructor recordEnv

                    -- Sort the fields of the constructor in the order of definition 
                    -- so the construction function can be mimic'd
                    let sortedFields = sortOn (\(n, (i, _, _, _)) -> i) (M.assocs recordFields)

                    -- For the old record we create a function type we can compare
                    -- with the constructor's typescheme. 
                    -- This way we can capture what typevariables were instantiated to.
                    let oldSortedBetas = map (\(n, (i, _, _, _)) -> TVar (@lhs.betaUnique + i + 1)) sortedFields
                    let oldFunc = foldr (.->.) @oldBeta oldSortedBetas

                    -- In the same way, try and sort the beta variables for each
                    -- of the update expressions according to the field they were used in.
                    -- For unused fields reuse the same beta variable generated for the old record
                    let sortedBetas = map (\(n, (i, _, _, _)) -> fromMaybe (TVar (@lhs.betaUnique + i + 1))
                            (lookup n @recordExpressionBindings.betasMap)) sortedFields

                    -- Create a function type with the beta variables in the order of the constructor function
                    -- This is an instantiation of the 'ctp' typescheme
                    let recordFunc = foldr (.->.) @beta sortedBetas

                    -- The record update's type corresponds to what beta will be instantiated to
                    let t = generalizeAll ([] .=>. snd (functionSpine (unqualify (unquantify ctp))))
                    return ( [ (@beta .::. t) @cinfo ]
                            , [ (@expression.beta .::. t) @cinfoOld, (@expression.beta .==. @oldBeta) @cinfoOld ]
                            , [ (recordFunc .::. ctp) @cinfoFunc ]
                            , [ (oldFunc .::. ctp) @cinfoFunc ]
                            , sortedFields
                            )

  | Variable
      lhs . betaUnique  = snd @updatedType
      loc . updatedType = maybe (undefined, @lhs.betaUnique) (freshen (@lhs.betaUnique) . unquantify) 
                            $ M.lookup @name.self $ typeEnvironment @lhs.importEnvironment
          . assumptions = @name.self `single` @beta
          . constraints = if isJust (M.lookup @name.self $ typeEnvironment @lhs.importEnvironment) then  
                                let (preds, tp) = split (fst @updatedType) in
                                Node $ [
                                    [ (@beta .==. tp) @cinfo] .>. Node[]
                                    , Receive @lhs.betaDeclUnique
                                    ] ++ [(unitTree $ TC2 $ Prove p @cinfo) | p <- preds ]
                            else 
                                Node [ Receive @lhs.betaDeclUnique ]
          . beta        = TVar @lhs.betaDeclUnique
  | Hole
      lhs . betaUnique  = @lhs.betaUnique + 1
      loc . assumptions = noAssumptions
          . constraints = emptyTree
          . beta        = TVar @lhs.betaUnique

  | NormalApplication
      function . betaUnique  = @lhs.betaUnique + 1
      loc      . assumptions = @function.assumptions `combine` @arguments.assumptions
               . constraints = @newcon .>.
                               Node [ @function.constraints
                                    , Node @arguments.constraintslist
                                    ]
               . beta        = TVar @lhs.betaUnique
               . newcon      = [ (@function.beta .==. foldr (.->.) @beta @arguments.betas) @cinfo ]

  | InfixApplication
      leftExpression . betaUnique  = @lhs.betaUnique + 1
      loc            . assumptions = @leftExpression.assumptions `combine` @operator.assumptions `combine` @rightExpression.assumptions
                     . constraints = @conTotal .>.
                                     Node [ @operator.constraints
                                          , @leftExpression.constraints
                                          , @rightExpression.constraints
                                          ]
                     . beta        = TVar @lhs.betaDeclUnique
                     . betaResOp   = TVar @lhs.betaUnique
                     . conOperator = (@operator.beta .==. @leftExpression.beta .->. @rightExpression.beta .->. @betaResOp) @cinfoOperator
                     . conTotal    = case (@leftExpression.section,@rightExpression.section) of
                                            (False,False) -> [ @conOperator, (@betaResOp     .==. @beta)                        @cinfoComplete     ]
                                            (True ,True ) -> [               (@operator.beta .==. @beta)                        @cinfoEmpty        ]
                                            (False,True ) -> [ @conOperator, (@rightExpression.beta .->. @betaResOp .==. @beta) @cinfoRightSection ]
                                            (True ,False) -> [ @conOperator, (@leftExpression.beta  .->. @betaResOp .==. @beta) @cinfoLeftSection  ]

  | If
      guardExpression . betaUnique  = @lhs.betaUnique + 1
      loc             . assumptions = @guardExpression.assumptions `combine` @thenExpression.assumptions `combine` @elseExpression.assumptions
                      . constraints = Node [ @conGuard .<. @guardExpression.constraints
                                           , @conThen  .<. @thenExpression.constraints
                                           , @conElse  .<. @elseExpression.constraints
                                           ]
                      . beta        = TVar @lhs.betaUnique
                      . conGuard    = [ (@guardExpression.beta .==. boolQualType) @cinfoGuard ]
                      . conThen     = [ (@thenExpression.beta  .==. @beta   ) @cinfoThen  ]
                      . conElse     = [ (@elseExpression.beta  .==. @beta   ) @cinfoElse  ]

  | Lambda
      expression . monos       = M.elems @patterns.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc        . constraints = @newcon .>. @csetBinds .>>.
                                 Node [ Node @patterns.constraintslist
                                      , @expression.constraints
                                      ]
                 . beta        = TVar @lhs.betaDeclUnique
                 . newcon      = [ (foldr (.->.) @expression.beta @patterns.betas .==. @beta) @cinfoType ]
      (loc.csetBinds, loc.assumptions) = (@patterns.environment .===. @expression.assumptions) @cinfoBind

  | Case
      alternatives . betaLeft    = @beta'
                   . betaRight   = @beta
      loc          . assumptions = @expression.assumptions `combine` @alternatives.assumptions
                   . constraints = Node [ @newcon .<. @expression.constraints
                                        , Node @alternatives.constraintslist
                                        ]
                   . beta        = TVar @lhs.betaDeclUnique
                   . beta'       = TVar $ @lhs.betaDeclUnique + 1
                   . newcon      = [ (@expression.beta .==. @beta') @cinfo ]

  | Let
      declarations . betaUnique     = @lhs.betaUnique + 1
                   . bindingGroups  = []
      loc          . constraints    = [ (@expression.beta .==. @beta) @cinfoType ] .>. @cset
                   . beta           = TVar @lhs.betaUnique

      (loc.assumptions, loc.cset, loc.inheritedBDG, loc.chunkNr, lhs.betaUnique, loc.implicitsFM) =
         let inputBDG   = (False, @lhs.currentChunk, @expression.uniqueChunk, @lhs.monos, @declarations.typeSignatures, mybdggroup, @expression.betaUnique)
             mybdggroup = Just (@expression.assumptions, [@expression.constraints])
         in performBindingGroup inputBDG @declarations.bindingGroups

  | Do
      lhs        . constraints   = Node [ @newcon .<. @statements.constraints ]
      statements . betaUnique    = @lhs.betaUnique + 1
                 . generatorBeta = Nothing
                 . assumptions   = noAssumptions
                 . monadBeta     = @loc.betaMonad
      loc        . assumptions   = @statements.assumptions
                 . constraints   = emptyTree
                 . beta          = TVar @lhs.betaUnique
                 . betaMonad     = TVar $ @lhs.betaDeclUnique
                 . betaVar       = TVar $ @lhs.betaDeclUnique + 1
                 . monadPredicate = Predicate "Prelude.Monad" @betaMonad
                 . monadType     = TApp @betaMonad @betaVar
                 . monadBeta     = quantify [] ([@monadPredicate] .=>. @monadType)
                 . newcon        = case @statements.generatorBeta of
                                      Nothing -> []
                                      Just b  -> [ (b .==. @beta) @cinfo, (@beta .::. @monadBeta) @cinfo ]

  | List
      expressions . betaUnique   = @lhs.betaUnique + 1
      loc         . constraints  = @newcon .>.
                                    Node (zipWith3 @zipf @expressions.betas [0..] @expressions.constraintslist)
                  . beta         = TVar @lhs.betaUnique
                  . beta'        = TVar @lhs.betaDeclUnique
                  . newcon       = [ (listType @beta' .==. @beta) @cinfoResult ]
                  . zipf         = \tp childNr ctree -> [ (tp .==. @beta') (@cinfoElem childNr) ] .<. ctree

  | Tuple
      loc         . constraints = @newcon .>. Node @expressions.constraintslist
                  . beta        = TVar @lhs.betaDeclUnique
                  . newcon      = [ (tupleType @expressions.betas .==. @beta) @cinfo ]

  | Typed
      expression . betaUnique  = @lhs.betaUnique + 1
      loc        . assumptions = @expression.assumptions
                 . constraints = @conResult .>.
                                 Node [ @conExpr .<. @expression.constraints ]
                 . beta        = TVar @lhs.betaUnique
                 . qualType    = convertTypeToQualified @lhs.importEnvironment @type.self
                 . typeScheme  = makeTpSchemeFromType @qualType 
                 . conResult   = [ (@beta            .::. @typeScheme) @cinfoResult          ]
                 . conExpr     = [ (@expression.beta !::! @typeScheme) @lhs.monos @cinfoExpr ]

  | Comprehension
      expression . monos       = @qualifiers.monos
                 . betaUnique  = @lhs.betaUnique + 1
      qualifiers . assumptions = @expression.assumptions
                 . constraints = @expression.constraints
                 . monos       = @lhs.monos
      loc        . assumptions = @qualifiers.assumptions
                 . constraints = @newcon .>. Node [ @qualifiers.constraints ]
                 . beta        = TVar @lhs.betaUnique
                 . newcon      = [ (listType @expression.beta .==. @beta) @cinfo, (@expression.beta .==. TVar @lhs.betaDeclUnique) @cinfo ]

  | Enum
       from . betaUnique   = @lhs.betaUnique + (if @overloaded then 1 else 0)
       loc  . assumptions  = @from.assumptions `combine` @then.assumptions `combine` @to.assumptions
            . constraints  = (@conList ++ @conPredicate) .>.
                             Node [ @conFrom .<. @from.constraints
                                  , @conThen .<. @then.constraints
                                  , @conTo   .<. @to.constraints
                                  ]
            . beta         = TVar @lhs.betaUnique
            -- TODO: We should not use 'enumFrom' here, as it might not be imported in every module
            . overloaded   = case M.lookup (nameFromString "enumFrom") (typeEnvironment @lhs.importEnvironment) of
                                Just scheme -> isOverloaded scheme
                                Nothing     -> False
            . elementType  = if @overloaded then TVar @lhs.betaDeclUnique else intQualType
            . conPredicate = if @overloaded then [predicate (Predicate "Prelude.Enum" @elementType) @cinfoPred] else []
            . conList      = [ (listType @elementType .==. @beta) @cinfoResult ]
            . conFrom      = [ (@from.beta .==. @elementType) @cinfoFrom ]
            . conThen      = [ (@then.beta .==. @elementType) @cinfoThen ]
            . conTo        = [ (@to.beta   .==. @elementType) @cinfoTo   ]

  | Negate
       loc        . constraints = @newcon .>. Node [ @expression.constraints ]
                  . beta        = TVar @lhs.betaDeclUnique
                  . newcon      = -- search for the type of 'negate' in the import envionment: otherwise use the default type.
                                  let standard = makeScheme [] [Predicate "Num" (TVar 0)] (TVar 0 .->. TVar 0)
                                      tpscheme = M.findWithDefault standard (nameFromString "negate") (typeEnvironment @lhs.importEnvironment)
                                  in [ (@expression.beta .->. @beta .::. tpscheme) @cinfo]

{- only for type inference without overloading -}
  | NegateFloat
       expression . betaUnique  = @lhs.betaUnique + 1
       loc        . constraints = @newcon .>. Node [ @expression.constraints ]
                  . beta        = TVar @lhs.betaUnique
                  . newcon      = [ (floatQualType .->. floatQualType .==. @expression.beta .->. @beta) @cinfo]

SEM Expressions

  | Cons
      lhs . betas           = @hd.beta : @tl.betas
          . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas           = []
          . assumptions     = noAssumptions
          . constraintslist = []

SEM MaybeExpression

  | Just
      lhs . section = False

  | Nothing
      lhs . section     = True
          . betaUnique  = @lhs.betaUnique + 1
          . assumptions = noAssumptions
          . constraints = emptyTree
      loc . beta        = TVar @lhs.betaUnique

---------------------------------------------------------------------------------------
-- Type Inferencing : GuardedExpression, GuardedExpressions

ATTR GuardedExpressions GuardedExpression [ typeConstructors : TypeConstructorEnvironment numberOfGuards:Int monos:Monos betaRight:Tp | betaUnique:Int | assumptions:Assumptions ]
ATTR GuardedExpressions                   [ | | constraintslist:ConstraintSets ]
ATTR                    GuardedExpression [ | | constraints:ConstraintSet      ]

SEM GuardedExpression

  | GuardedExpression
      lhs . constraints = Node [ @newconGuard .<. @guard.constraints
                               , @newconExpr  .<. @expression.constraints
                               ]
          . assumptions = @guard.assumptions `combine` @expression.assumptions
      loc . newconGuard = [ (@guard.beta .==. boolQualType) @cinfoGuard ]
          . newconExpr  = [ (@expression.beta .==. @lhs.betaRight) @cinfoExpr ]

SEM GuardedExpressions

  | Cons
      lhs . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . assumptions     = noAssumptions
          . constraintslist = []

---------------------------------------------------------------------------------------
-- Type Inferencing : RecordExpressionBinding, RecordExpressionBindings

ATTR RecordExpressionBindings RecordExpressionBinding [ betaConstr:{Tp} monos:Monos | betaUnique:Int | assumptions:Assumptions ]
ATTR RecordExpressionBindings                         [ | | betasMap:{[(Name, Tp)]} constraintslist:ConstraintSets ]
ATTR                    RecordExpressionBinding       [ | | betaMap:{(Name, Tp)} constraints:ConstraintSet      ]

SEM RecordExpressionBinding

  | RecordExpressionBinding
      lhs . constraints  = @newcon .>. Node [@expression.constraints]
          . assumptions  = @expression.assumptions
      loc . beta         = TVar @lhs.betaDeclUnique
          . betaMap      = (@name.self, @expression.beta)
          . recordEnv    = recordEnvironment @lhs.importEnvironment
          . newcon       =
                fromMaybe (internalError "TypeInferenceRules.ag" "RecordExpressionBinding"
                    ("Specified record field could not be found: "
                    ++ show @name.self
                    )) $
                    do
                        constructors <- M.lookup @name.self (fieldLookup @lhs.importEnvironment)
                        recordFields <- M.lookup (head constructors) @recordEnv
                        recordType <- M.lookup @name.self recordFields
                        return [(@expression.beta .==. @beta) @cinfoExpr]

SEM RecordExpressionBindings

  | Cons
      lhs . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist
          . betasMap        = @hd.betaMap : @tl.betasMap

  | Nil
      lhs . assumptions     = noAssumptions
          . constraintslist = []
          . betasMap        = []

---------------------------------------------------------------------------------------
-- Type Inferencing : Pattern

ATTR Pattern Patterns [ typeConstructors : TypeConstructorEnvironment monos:Monos | betaUnique:Int | environment:PatternAssumptions ]
ATTR Pattern          [ | | constraints:ConstraintSet ]
ATTR         Patterns [ | | betas:Tps constraintslist:ConstraintSets numberOfPatterns:Int ]

SEM Pattern
  | Hole
      lhs . environment = noAssumptions
      loc . constraints = emptyTree

  | Literal
      lhs . environment = noAssumptions
      loc . constraints = unitTree ((@literal.literalType .==. @beta) @cinfo)

  | Variable
      lhs . environment = M.singleton @name.self @beta
      loc . constraints = Receive @lhs.betaDeclUnique

  | InfixConstructor
      lhs         . environment    = @leftPattern.environment `M.union` @rightPattern.environment
      leftPattern . betaUnique     = @lhs.betaUnique + 1
      loc         . constraints    = @conApply .>.
                                     Node [ listTree @conConstructor
                                          , @leftPattern.constraints
                                          , @rightPattern.constraints
                                          ]
                  . betaCon        = TVar @lhs.betaUnique
                  . conApply       = [ (@betaCon .==. @leftPattern.beta .->. @rightPattern.beta .->. @beta) @cinfoApply ]
                  . conConstructor = case M.lookup @constructorOperator.self (valueConstructors @lhs.importEnvironment) of
                                        Nothing          -> []
                                        Just (_, ctp, _) -> [ (@betaCon .::. ctp) @cinfoConstructor ]

  | Constructor
      patterns . betaUnique     = @lhs.betaUnique + 1
      loc      . constraints    = @conApply .>.
                                  Node [ listTree @conConstructor
                                       , Node @patterns.constraintslist
                                       ]
               . betaCon        = TVar @lhs.betaUnique
               . conApply       = [ (@betaCon .==. foldr (.->.) @beta @patterns.betas)
                                    (if @patterns.numberOfPatterns == 0  then @cinfoEmpty else @cinfoApply) ]
               . conConstructor = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                     Nothing          -> []
                                     Just (_, ctp, _) -> [ (@betaCon .::. ctp) @cinfoConstructor ]

  | Record
      recordPatternBindings . betaUnique  = @lhs.betaUnique + 1
      recordPatternBindings . betaCon     = @beta
      recordPatternBindings . nameCon     = @name.self
      lhs      . environment    = @recordPatternBindings.environment 
      lhs      . assumptions    = @recordPatternBindings.assumptions 
      loc      . constraints    = [] .>.
                                  Node @recordPatternBindings.constraintslist

  | As
      lhs     . environment = M.insert @name.self @beta @pattern.environment
      loc     . constraints = @newcon .>.
                              Node [ Receive @lhs.betaDeclUnique
                                   , @pattern.constraints
                                   ]
              . newcon      = [ (@beta .==. @pattern.beta) @cinfo ]

  | Wildcard
      lhs . environment = noAssumptions
      loc . constraints = emptyTree

  | List
      patterns . betaUnique   = @lhs.betaUnique + 1
      loc      . constraints  = @newcon .>.
                                Node (zipWith3 @zipf @patterns.betas [0..] @patterns.constraintslist)
               . beta'        = TVar @lhs.betaUnique
               . newcon       = [ (listType @beta' .==. @beta) @cinfoResult ]
               . zipf         = \tp elemNr ctree -> [ (tp .==. @beta') (@cinfoElem elemNr) ] .<. ctree

  | Tuple
      loc      . constraints = @newcon .>. Node @patterns.constraintslist
               . newcon      = [ (tupleType @patterns.betas .==. @beta) @cinfo ]

  | Negate
      lhs . environment = noAssumptions
      loc . constraints = listTree @newcon
          . newcon      = -- The parser only accepts a literal after '-' in a Pattern
                          -- search for the type of 'negate' in the import envionment: otherwise use the default type.
                          let standard = makeScheme [] [Predicate "Num" (TVar 0)] (TVar 0 .->. TVar 0)
                              tpscheme = M.findWithDefault standard (nameFromString "negate") (typeEnvironment @lhs.importEnvironment)
                          in [ (@literal.literalType .->. @beta .::. tpscheme) @cinfo]

{- only if type inferencing without overloading -}
  | NegateFloat
      lhs . environment = noAssumptions
      loc . constraints = listTree @newcon
          . newcon      = -- The parser only accepts a literal after '-.' in a Pattern
                          [ (floatQualType .==. @beta) @cinfo ]

SEM Patterns

  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . environment      = @hd.environment `M.union` @tl.environment
          . numberOfPatterns = 1 + @tl.numberOfPatterns
          . constraintslist  = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas            = []
          . environment      = noAssumptions
          . numberOfPatterns = 0
          . constraintslist  = []

---------------------------------------------------------------------------------------
-- Type Inferencing : RecordPatternBinding, RecordPatternBindings
ATTR RecordPatternBinding RecordPatternBindings [ nameCon:Name betaCon:Tp monos:Monos | betaUnique:Int | environment:PatternAssumptions ]
ATTR RecordPatternBinding                       [ | | beta:{ (Int, Tp) } constraints:ConstraintSet ]
ATTR                      RecordPatternBindings [ | | betas:{ [(Int, Tp)] } constraintslist:ConstraintSets numberOfPatterns:Int ]

SEM RecordPatternBindings
  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . environment      = @hd.environment `M.union` @tl.environment
          . numberOfPatterns = 1 + @tl.numberOfPatterns
          . constraintslist  = @hd.constraints : @tl.constraintslist
  | Nil
      lhs . betas            = []
          . environment      = noAssumptions
          . numberOfPatterns = 0
          . constraintslist  = []

SEM RecordPatternBinding
  | RecordPatternBinding
      lhs . environment = @pattern.environment
          . constraints = @selCon .>. @pattern.constraints
          . beta        = (@order, @beta)
      loc . recordEnv   = recordEnvironment @lhs.importEnvironment
          . selCon      = [ (@lhs.betaCon .->. @beta .::. fth4 @field) @cinfo, (@beta .==. @pattern.beta) @cinfo ]
          . order       = fst4 @field
          . field       = fromMaybe (internalError
                            "TypeInferenceRules.ag" 
                            "RecordPatternBinding"
                            ("Specified field could not be found: " ++ show @name.self)) 
                                (M.lookup @name.self @recordFields)
          . recordFields = fromMaybe (internalError
                            "TypeInferenceRules.ag"
                            "RecordPatternBinding"
                            ("Specified constructor could not be found: " ++ show @lhs.nameCon)) 
                                (M.lookup @lhs.nameCon @recordEnv)

---------------------------------------------------------------------------------------
-- Type Inferencing : Alternative, Alternatives

ATTR Alternative Alternatives [ typeConstructors : TypeConstructorEnvironment betaLeft:Tp betaRight:Tp monos:Monos | betaUnique:Int | assumptions:Assumptions ]
ATTR Alternative              [ | | constraints:ConstraintSet ]
ATTR             Alternatives [ | | constraintslist:ConstraintSets ]

SEM Alternative

  | Hole
      lhs . assumptions = noAssumptions
      loc . constraints = emptyTree

  | Alternative
      righthandside . monos       = M.elems @pattern.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc           . constraints = @csetBinds .>>.
                                    Node [ @conLeft  .<. @pattern.constraints
                                         , @righthandside.constraints
                                         ]
                    . conLeft     = [ (@pattern.beta .==. @lhs.betaLeft) @cinfoLeft ]
      (loc.csetBinds,lhs.assumptions) = (@pattern.environment .===. @righthandside.assumptions) @cinfoBind

  | Empty
      lhs . assumptions = noAssumptions
      loc . constraints = emptyTree

SEM Alternatives

  | Cons
      lhs . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . assumptions     = noAssumptions
          . constraintslist = []

---------------------------------------------------------------------------------------
-- Type Inferencing : Statement, Statements, Qualifier, Qualifiers

ATTR Statement Statements Qualifier Qualifiers [ typeConstructors : TypeConstructorEnvironment | assumptions:Assumptions betaUnique:Int constraints:ConstraintSet | ]
ATTR Statement Statements                      [ monadBeta : Tp | generatorBeta:{Maybe Tp} | ]
ATTR Statement            Qualifier Qualifiers [ | monos:Monos | ]
ATTR           Statements                      [ monos:Monos | | ]

SEM Statement

  | Expression
      lhs        . generatorBeta  = Just @beta
                 . assumptions    = @lhs.assumptions `combine` @expression.assumptions
                 . constraints    = @locConstraints
      expression . betaUnique     = @lhs.betaUnique + 1
      loc        . locConstraints = Node [ @newcon .<. @expression.constraints
                                         , @lhs.constraints
                                         ]
                 . beta           = TVar @lhs.betaUnique
                 . betaRes        = TVar @lhs.betaDeclUnique
                 . newcon         = [ (@expression.beta .==. @beta) @cinfo, (@beta .==. TApp @lhs.monadBeta @betaRes) @cinfo]

  | Let
      lhs          . generatorBeta  = Nothing
      declarations . bindingGroups  = []
      (lhs.assumptions, lhs.constraints, loc.inheritedBDG, loc.chunkNr, lhs.betaUnique, loc.implicitsFM) =
         let inputBDG    = (False, @lhs.currentChunk, @declarations.uniqueChunk, @lhs.monos, @declarations.typeSignatures, mybdggroup, @declarations.betaUnique)
             mybdggroup = Just (@lhs.assumptions, [@lhs.constraints])
         in performBindingGroup inputBDG @declarations.bindingGroups



  | Generator
      lhs . generatorBeta = Nothing
          . constraints   = @locConstraints
          . assumptions   = @assumptions' `combine` @expression.assumptions
          . monos         = M.elems @pattern.environment ++ getMonos @csetBinds ++ @lhs.monos
          . betaUnique    = @expression.betaUnique
      pattern . betaUnique = @lhs.betaUnique + 2
      expression . betaUnique = @pattern.betaUnique
      
      
      loc . locConstraints = @newcon .>. @csetBinds .>>.
                                Node [ @pattern.constraints
                                     , @expression.constraints
                                     , @lhs.constraints
                                     ]
          . beta          = TVar $ @lhs.betaUnique + 1
          . newcon        = [(@expression.beta .==. (TApp @lhs.monadBeta @pattern.beta)) @cinfoResult]
          . (csetBinds,assumptions') = (@pattern.environment .===. @lhs.assumptions) @cinfoBind

SEM Statements

  | Cons
      lhs . assumptions = @hd.assumptions
          . constraints = @hd.constraints
      hd  . assumptions = @tl.assumptions
          . constraints = @tl.constraints
      tl  . assumptions = @lhs.assumptions
          . constraints = @lhs.constraints

SEM Qualifier

  | Guard
      lhs . assumptions = @lhs.assumptions `combine` @guard.assumptions
          . constraints = @locConstraints
      loc . locConstraints = Node [ @newcon .<. @guard.constraints
                                  , @lhs.constraints
                                  ]
          . newcon      = [ (@guard.beta .==. boolQualType) @cinfo ]

  | Let   declarations . bindingGroups  = []
          (lhs.assumptions, lhs.constraints, loc.inheritedBDG, loc.chunkNr, lhs.betaUnique, loc.implicitsFM) =
             let inputBDG   = (False, @lhs.currentChunk, @declarations.uniqueChunk, @lhs.monos, @declarations.typeSignatures, mybdggroup, @declarations.betaUnique)
                 mybdggroup = Just (@lhs.assumptions, [@lhs.constraints])
             in performBindingGroup inputBDG @declarations.bindingGroups


  | Generator
      lhs . assumptions = @assumptions' `combine` @expression.assumptions
          . constraints = @locConstraints
          . monos       = M.elems @pattern.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc . locConstraints = @newcon .>. @csetBinds .>>.
                                Node [ @pattern.constraints
                                     , @expression.constraints
                                     , @lhs.constraints
                                     ]
          . (csetBinds,assumptions') = (@pattern.environment .===. @lhs.assumptions) @cinfoBind
          . newcon      = [ (@expression.beta .==. listType @pattern.beta) @cinfoResult ]

SEM Qualifiers

  | Cons
      lhs . assumptions = @hd.assumptions
          . constraints = @hd.constraints
      hd  . assumptions = @tl.assumptions
          . constraints = @tl.constraints
      tl  . assumptions = @lhs.assumptions
          . constraints = @lhs.constraints

---------------------------------------------------------------------------------------
-- Type Inferencing : Literal

ATTR Literal [ | | literalType:Tp ]

SEM Literal
  | Int     lhs . literalType = intQualType    --intType
  | Char    lhs . literalType = charQualType   --charType
  | String  lhs . literalType = stringQualType --stringType
  | Float   lhs . literalType = floatQualType  --floatType
